{
  "_id": "5aa8ab9f3bfa39001ca537f0",
  "nodeId": "5aa8ab9e3bfa39001ca537ee",
  "type": "code:0.0.1:local:32498h32f2",
  "data": {
    "key": "08b17f71-3221-4919-a875-af0b4522f81b",
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Challenge solved by caller (or so they say) \n      // - create Node for ExternalIdentity: publicKey, approvedDatetime\n      // - return JWT that client should use for subsequent requests \n      \n      // old: also receiving an INPUT.data.internalUserPassphrase for logging in! \n      \n      let storedChallenge = universe.globalCache[INPUT.data.publicKey];\n      \n      // check stored challenge with passed-in (any reason? seems ok) \n      if(storedChallenge != INPUT.data.challengeReceived){\n        return resolve({\n          type: 'error',\n          data: {\n            str: 'invalid storedChallenge != challengeReceived'\n          }\n        })  \n      }\n      \n      // Verify challenge I sent \n      let verified = await universe.capabilities().verify({\n        type: 'challenge_verify:0.0.1:local:93fj92hj832ff2',\n        data: {\n          challenge: storedChallenge,\n          solution: INPUT.data.solution,\n          publicKey: INPUT.data.publicKey\n        }\n      });\n      if(!verified.data){\n        return resolve({\n          type: 'error...',\n          data: {\n            err: 'Failed verifiation!'\n          }\n        });\n      }\n      \n      // Create local Node for ExternalIdentity \n      // - they should have already passed up a token I can use for auth (if I want to reach this Second again) \n      // - should also have the connect_method setup! \n      \n      \n      // Get local ExternalIdentity if it exists \n      let nodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: 'external_identity:0.0.1:local:8982f982j92',\n            data: {\n              publicKey: INPUT.data.publicKey\n            }\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            return tmpNodes;\n          }\n        }\n      });\n      \n      let ExternalIdentityNode\n      if(nodes.length){\n        // Exists already \n        ExternalIdentityNode = nodes[0];\n        \n        // todo: get updated connectMethod!!!\n        universe.console.error('Expecting connectMethod for one we are creating');\n        universe.console.error('Received:', JSON.stringify(INPUT, null, 2));\n        \n        // update connect_method (if sent up in INPUT) \n        if(INPUT.data.connectMethod){\n          if(ExternalIdentityNode.nodes){\n            // has existing connect_method to be updated\n            \n            console.log('Updating existing connect_method for external child');\n            \n            let updateChild = {\n              _id: ExternalIdentityNode.nodes[0]._id,\n              nodeId: ExternalIdentityNode._id,\n              type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn',\n              data: INPUT.data.connectMethod\n            }\n            let updatedChild = await universe.updateNode(updateChild);\n            \n          } else {\n            // no existing connect_method\n            let newChild = {\n              nodeId: savedNode._id,\n              type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn',\n              data: INPUT.data.connectMethod\n            }\n            let savedChild = await universe.newNode(newChild);\n          }\n        }\n        \n        \n      } else {\n        // no Node created yet (this is expected for each \"new\" Second) \n        \n        // go ahead and create new ExternalIdentityNode \n        // - also creating the Connect Method to use \n        //   - it would have been sent up (\"reach me X way\") \n        \n        let newNode = {\n          type: 'external_identity:0.0.1:local:8982f982j92',\n          data: {\n            publicKey: INPUT.data.publicKey\n          }\n        }\n        \n        let savedNode = await universe.newNode(newNode);\n        \n        // create connect_method (if sent up in INPUT) \n        if(INPUT.data.connectMethod){\n          let newChild2 = {\n            nodeId: savedNode._id,\n            type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn',\n            data: INPUT.data.connectMethod\n          }\n          let savedChild2 = await universe.newNode(newChild2);\n        }\n        \n        // get normal Node for rest of call \n        ExternalIdentityNode = await universe.findNode({_id: savedNode._id});\n        \n      }\n      \n      \n      // // get internal_user that we are authorizing as (using \"upgrade\" path now...)\n      // // - should ERROR if fail! \n      // if(INPUT.data.internalUserPassphrase){\n        \n      // }\n      \n      \n      // // has connect_method (external_identity_connect_method:0.0.1:local:382989239hsdfmn)?\n      // let connectNode = universe.lodash.find(ExternalIdentityNode.nodes, {type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn'});\n      // if(!connectNode){\n      //   return resolve({\n      //     type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n      //     data: {\n      //       str: 'Missing existing ExternalIdentity connect_method child!'\n      //     }\n      //   })\n      // }\n      \n      \n      // Created encrypted token for identification \n      let tokenDataString = JSON.stringify({\n        type: 'identity_token_encrypted:0.0.1:local:8928h9h88832',\n        data: {\n          internalId: ExternalIdentityNode._id,\n          publicKey: INPUT.data.publicKey\n        }\n      });\n      \n      \n      // encrypt_string:0.0.1:local:329fj2938\n      let encrypted = await universe.capabilities().encryptPrivate({\n        type: 'string',\n        data: tokenDataString\n      });\n      \n      let token = encrypted.data;\n      \n      // resolve({\n      //   type: 'string:',\n      //   data: encrypted.data\n      // });\n        \n      \n      return resolve({\n        type: 'challenge_token_response:0.0.1:local:928h92h3223fdfsdf23',\n        data: {\n          verified: true,\n          token\n        }\n      });\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  },
  "active": true,
  "createdAt": 1521003423728,
  "updatedAt": null
}