{
  "_id": "5aa8abb93bfa39001ca53817",
  "nodeId": "5aa8abb73bfa39001ca53815",
  "type": "code:0.0.1:local:32498h32f2",
  "data": {
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Being passed in the publicKey we want to initiate a challenge with \n      // - also sending our \"connect_method\" info (if it exists) \n      \n      \n      // INPUT.type == \"challenge_init_remote:0.0.1:...\"\n      // INPUT.data == { \n      //   ExternalIdentityNode: { data: {publicKey:Strig}, nodes: [connect_method] }\n      // }\n      \n      // Save ExternalIdentityNode locally! \n      // - required before Identifying \n      // - saveExternal *should* handle duplicates (and updating the initial AuthPassphrase) \n      let ExternalIdentityNode = await universe.loadAndRunCapability('Identity',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'saveExternal',\n          options: {\n            ExternalIdentityNode: INPUT.data.ExternalIdentityNode // should contain a connection method! \n          }\n        }\n      });\n      \n      console.log('Saved new/updated ExternalIdentityNode', ExternalIdentityNode);\n      \n      \n      // Authenticate with External Second \n      // - make authenticated requests to a Second (necessary for Learning?) \n      //   - should have ALL requests authenticated \n      // universe.setupExternalSecond();\n      let authExternalIdentityNode = await universe.loadAndRunCapability('IdentifyInitiate',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'start',\n          options: {\n            externalIdentityPublicKey: ExternalIdentityNode.data.publicKey,\n            // authToken: 'eeaac41bdb1b717d137a53779db97457:07e0fbe19e72c3ff7e329fc293bcf5b51d780c4c3c60f80403b2fea8f30d0daa5e4891dbdd6c57d9844622078a681853f31202d0632f0ee95031c9369a60708ddb6220e248e3c2ec6b3bb3c00eb2425aea922351d7128ef333ea5fe6a8ad139c1978759e29b057db1e655f2fe7c8962e'\n          }\n        }\n      });\n      \n      return resolve({\n        ExternalIdentityNode,\n        authExternalIdentityNode\n      })\n      \n      // // return resolve({\n      // //   msg: 'Being asked to auth with a remote!',\n      // //   INPUT\n      // // });\n      \n      \n      \n      // // Currently ExternalIdentity is unique by the publicKey (cant have multiple identities with the same publicKey) \n      // // - can have multiple connect_method's though! (websocket, etc.) \n      \n      // // // INPUT: \n      // // {\n      // //   type: 'key_public:0.0.1:local:3928fhj2389f',\n      // //   data: 'string'\n      // // }\n      \n      \n      // // Initiates a challenge with an external Second \n      // // - ExternalIdentity should ALREADY EXIST locally! \n      // //   - look it up from nodes by INPUT.data.publicKey \n      // // - lookup by data:publicKey, childNode:type:connect_method \n      // // - checks for local ExternalIdentity first! \n      // // - \n      \n      // // return resolve({\n      // //   INPUT\n      // // });\n      \n      \n      // // Get local ExternalIdentity if it exists \n      // let nodes = await universe.searchMemory({\n      //   filter: {\n      //     sqlFilter: {\n      //       type: 'external_identity:0.0.1:local:8982f982j92',\n      //       data: {\n      //         publicKey: INPUT.data\n      //       }\n      //     },\n      //     // function for returning data from the Node, after filtering a bit \n      //     // - includes both the Node, and Nodes with nodeId (pointers) \n      //     filterNodes: tmpNodes=>{\n      //       return tmpNodes;\n      //     }\n      //   }\n      // });\n      \n      // if(!nodes.length){\n      //   return resolve({\n      //     type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n      //     data: {\n      //       str: 'Missing existing ExternalIdentity node',\n      //       publicKey: INPUT.data\n      //     }\n      //   })\n      // }\n      \n      // let ExternalIdentityNode = nodes[0];\n      // // else {\n      // //   ExternalIdentityNode = {\n      // //     // no _id yet! (will create/update later!) \n      // //     type: 'external_identity:0.0.1:local:8982f982j92',\n      // //     data: {\n      // //       publicKey:INPUT.data\n      // //     }\n      // //   }\n      // // }\n      \n      // // has connect_method (external_identity_connect_method:0.0.1:local:382989239hsdfmn)?\n      // let connectNode = universe.lodash.find(ExternalIdentityNode.nodes, {type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn'});\n      // if(!connectNode){\n      //   return resolve({\n      //     type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n      //     data: {\n      //       str: 'Missing existing ExternalIdentity connect_method child!'\n      //     }\n      //   })\n      // }\n      \n      \n      \n      // // Initiate Auth Steps \n      // // - send my publicKey, new challengeText that we want validated \n      // let MyPrivateIdentity = await universe.capabilities().privateIdentity();\n      // let myPublicKey = MyPrivateIdentity.data.public;\n      // let newChallenge = universe.uuidv4();\n      \n      // universe.console.log('Created NewChallenge:', newChallenge);\n      \n      // // make Node request to datasource\n      // let InitiateIdentifyNode = {\n      //   type: 'challenge_initiate_info:0.0.1:local:323023424234324dwf',\n      //   data: {\n      //     publicKey: myPublicKey,\n      //     challenge: newChallenge\n      //   }\n      // }\n      // let WrappedInitiateIdentifyNode = {\n      //   type: 'run_action:0.0.1:local:2398y294c23',\n      //   data: {\n      //     matchActionType: 'identify_challenge_start:0.0.1:local:3892fh83h46',\n      //     dataForAction: InitiateIdentifyNode\n      //   }\n      // }\n      \n      // let ExternalInitialResponseNodeFull = await universe.capabilities().externalRequest({\n      //   type: 'external_request_info:0.0.1:local:329fj239832h93f23',\n      //   data: {\n      //     ExternalIdentityNode, // must include connect_method\n      //     RequestNode: WrappedInitiateIdentifyNode\n      //   }\n      // });\n      // // response includes the \"output_generic\" wrapper \n      // let ExternalInitialResponseNode = ExternalInitialResponseNodeFull.data;\n      \n      // // // successful response: challenge_start_response\n      // // return resolve({\n      // //   ok: 'test1',\n      // //   response: ExternalInitialResponse\n      // // });\n      \n      // // Received:\n      // // - answered challenge, signed using Private Key of External, verify using their PublicKey \n      // // - new challenge for me to answer (to verify myself!), so I can get a JWT! \n      // // - \n      \n      \n      // // Verify challenge I sent \n      // let verified = await universe.capabilities().verify({\n      //   type: 'challenge_verify:0.0.1:local:93fj92hj832ff2',\n      //   data: {\n      //     challenge: newChallenge,\n      //     solution: ExternalInitialResponseNode.data.solution,\n      //     publicKey: ExternalIdentityNode.data.publicKey\n      //   }\n      // });\n      // // boolean Node is returned\n      // if(!verified.data){\n      //   return resolve({\n      //     err: 'Failed verifiation!',\n      //     challenge: newChallenge,\n      //     solution: ExternalInitialResponseNode.data.solution,\n      //     publicKey: ExternalIdentityNode.data.publicKey\n      //   });\n      // }\n      \n      \n      // // return resolve({\n      // //   verified: verified\n      // // });\n      \n      \n      // // Verified external! \n      // // - now need to identify myself, by answering the challenge I was sent \n      // // - really this could be completed in reverse (but might as well just do it here!) \n      // //   - better to do it in a handshake, otherwise the External might just say \"I was only holding your info for a moment and I got tired of holding it while I didn't know who you were\" \n      // let SignedNode = await universe.capabilities().sign({\n      //   type: 'string:0.0.1:local:289hf329h93',\n      //   data: ExternalInitialResponseNode.data.challenge\n      // });\n      \n      // // Make Node request to External, using my publicKey and the challenge/solution I was sent \n      // // - getting a JWT back! \n      // let GetIdentityTokenNode = {\n      //   type: 'challenge_get_token:0.0.1:local:9238f9hf923',\n      //   data: {\n      //     publicKey: myPublicKey,\n      //     challengeReceived: ExternalInitialResponseNode.data.challenge,\n      //     solution: SignedNode.data // base64 string \n      //   }\n      // }\n      // let WrappedTokenNode = {\n      //   type: 'run_action:0.0.1:local:2398y294c23',\n      //   data: {\n      //     matchActionType: 'identify_challenge_response:0.0.1:local:3289h988h293fh8h',\n      //     dataForAction: GetIdentityTokenNode\n      //   }\n      // }\n      // let ExternalTokenResponseFull = await universe.capabilities().externalRequest({\n      //   type: 'external_request_info:0.0.1:local:329fj239832h93f23',\n      //   data: {\n      //     ExternalIdentityNode, // must include connect_method\n      //     RequestNode: WrappedTokenNode\n      //   }\n      // });\n      \n      // // return resolve({\n      // //   x: 1,\n      // //   ExternalTokenResponseFull\n      // // });\n      \n      // // response includes the \"output_generic\" wrapper \n      // let ExternalTokenResponseNode = ExternalTokenResponseFull.data;\n      \n      // // save updated ExternalIdentityNode\n      // ExternalIdentityNode.data.token = ExternalTokenResponseNode.data.token; // assuming Node response w/ encrypted token as data\n      // let updatedExternalIdentityNode = await universe.updateNode(ExternalIdentityNode);\n      // // todo: save\n      \n      // // check for publicKey info (ok to allow this person?) \n      // // - after I send them something to sign and actually get their identity...\n      \n      // resolve({\n      //   type: 'challenge_finish:0.0.1:local:2983jf982',\n      //   data: {\n      //     SUCCESS: {\n      //       ExternalInitialResponseNode,\n      //       ExternalTokenResponseNode,\n      //       SignedNode_data: SignedNode.data,\n      //       updatedExternalIdentityNode\n      //     }\n      //   }\n      // });\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()",
    "key": "42b3702f-e4b8-4f0b-89c5-26d1477054ff",
    "note": "action: Identify Challenge Initiate"
  },
  "active": true,
  "createdAt": 1521003449526,
  "updatedAt": 1521415783274
}