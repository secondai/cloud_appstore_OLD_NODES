{
  "_id": "5aa8abb53bfa39001ca53812",
  "nodeId": "5aa8abb43bfa39001ca53810",
  "type": "code:0.0.1:local:32498h32f2",
  "data": {
    "key": "c9825374-18ab-414e-bad3-011830343c74",
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      // get the User\n      let requestCache = await universe.getRequestCache();\n      \n      // resolve({\n      //   cache: true,\n      //   requestCache\n      // });\n      \n      let { optionsNode, dataNode } = INPUT.data;\n      \n      // being given a Node that we are supposed to Learn\n      // - should run authentication first? \n      // - or assume authentication already happened? \n      // - just get the current user (using some Logic call?) \n      \n      // store another Node with the sent-in _id, so that we can match up later \n      // - when adding this Node, see if any other Nodes have a PointerNode/ChildNode of the type \"external_learned_node:0.0.1:local:23432f420f983\" and the data \n      \n      \n      // shouldnt use exactly \"searchMemory\" but should instead have a type/schema also? \n      let nodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: dataNode.type,\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            // this runs isolated, outside of the above context? (not sure) \n            return new Promise((resolve, reject)=>{\n              tmpNodes = tmpNodes.filter(tmpNode=>{\n                let hasPointer = (tmpNode.nodes || []).filter(pointerNode=>{\n                  return pointerNode.type == \"external_learned_node:0.0.1:local:23432f420f983\";\n                });\n                return hasPointer.length > 0;\n              })\n              resolve(tmpNodes);\n            });\n          },\n        }\n      });\n      \n      let NodeToSave = {\n        type: dataNode.type,\n        nodeId: dataNode.nodeId,\n        data: dataNode.data\n      }\n      \n      if(nodes.length && !optionsNode.data.skipExistingLearnedNodeId){\n        // use only the 1st! \n        // - todo: report problem if > 1 \n        NodeToSave.nodeId = nodes[0]._id;\n      }\n      \n      // save Node to memory\n      let savedNode = await universe.newNode(NodeToSave);\n      \n      // Need to create a PointerNode with the \"old\" id if it existed! \n      // - this should be an option, passed as a Node (instead of having INPUT as the Node!) \n      let savedNodeChild;\n      if(dataNode._id){\n        let NodeChildToSave = {\n          nodeId: savedNode._id,\n          type: \"external_learned_node:0.0.1:local:23432f420f983\",\n          data: {\n            oldId: dataNode._id\n          }\n        }\n        savedNodeChild = await universe.newNode(NodeChildToSave);\n      }\n      \n      resolve({\n        type: 'node:...',\n        data: savedNode,\n          // child: savedNodeChild\n      });\n      \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n  })\n})()"
  },
  "active": true,
  "createdAt": 1521003445805,
  "updatedAt": null
}