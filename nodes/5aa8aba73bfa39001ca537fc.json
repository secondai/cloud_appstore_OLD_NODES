{
  "_id": "5aa8aba73bfa39001ca537fc",
  "nodeId": "5aa8aba63bfa39001ca537fa",
  "type": "code:0.0.1:local:32498h32f2",
  "data": {
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // return resolve({\n      //   SEARCHING: 'seraching internal datasource!',\n      //   INPUT,\n      //   SELF\n      // });\n      \n      // schema/format of INPUT data: standard_query_request:0.0.1:local:65723f2khfds\n      \n      await universe.historyLog({INPUT}, 'searching-internal-datasource', 'debug')\n      \n      \n      // When searching: (permissions) \n      // - search is coming from a remote user (always!!!) \n      // - checking \"permission functions\" to determine what data to share \n      // - should already have created the AuthUser (in the universe.responsesCache) and other relevant permission information \n      \n      \n      // get all base (no nodeId) Nodes .... actually, get ALLLLLL Nodes! \n      // for each Node, run the permission functions \n      // - each child node (in the tree, go all the way down, recurse up!) \n      // after doing all child Nodes, do the parent Node \n      // - undefined means to leave it out \n      // - use universe.requestsCache for AuthUser, etc. \n      // after running all the permission functions, pass the Node to the parent \n      // return an array, without running any more analysis (do v2 locally) \n      \n      // permission functions are per-Node (stored as a type:permission_function that has a type:code as a NodeChild) \n      // permission functions are also per-Type, stored as a single Node for the type, of type:type_permission_function\n      \n      let startTime = (new Date()).getTime();\n      \n      let vmFuncCount = 0;\n      \n      // shouldnt use exactly \"searchMemory\" but should instead have a type/schema also? \n      // console.log('Searching internal datasource1');\n      let nodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            // // type: NODE.type,\n            // nodeId: null,\n            active: true\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            // this runs isolated, outside of the above context? (not sure) \n            \n            // action_pointer:0.0.1:local:238972ncr\n            \n            return new Promise((resolve, reject)=>{\n              // if(x==1){\n              //   resolve([{type:'FAKE'}]);\n              // }\n              resolve(tmpNodes);\n            });\n          },\n        }\n      });\n      // console.log('Searching internal datasource2');\n      \n      // loading all the PermissionNodes that are for method:read, cuz we'll repeatedly try each \n      let permissionFunctionNodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: \"permission_function:0.0.1:local:2387872h3f2\",\n            nodeId: null // top-level\n          },\n          filterNodes: tmpNodes=>{\n            return new Promise((resolve, reject)=>{\n              tmpNodes = tmpNodes.filter(tmpNode=>{\n                return tmpNode.data.method == 'read';\n              })\n              resolve(tmpNodes);\n            });\n          },\n        }\n      });\n      permissionFunctionNodes = universe.lodash.sortBy(permissionFunctionNodes,funcNode=>{\n        let orderNode = universe.lodash.find(funcNode.nodes, {type: 'order_level:0.0.1:local:382hf273'});\n        return orderNode ? orderNode.data.level:0;\n      });\n      \n      let memoryTime = (new Date()).getTime();\n      \n      // await universe.historyLog({}, 'searching-internal-datasource2', 'debug')\n      \n      // return resolve({\n      //   nodes: nodes.length\n      // });\n      \n      let workGroup = (new Date()).getTime().toString(); // use this for concurrency\n      \n      let requestCache = await universe.getRequestCache({});\n      \n      // Instead of creating a bunch of small VMs to run...\n      // - assuming this container is OK \n      // - run analysis of the code snippets to make sure they are OK to run \n      // - use \"eval\" and create locally-accessible variables \n      // ....end result: exponentially faster \n      \n      \n      // Fetched all Nodes \n      // - iterate over nodes \n      let returnNodes = [];\n      let promises = [];\n      // for(let node of nodes){\n      nodes.forEach(node=>{\n        \n        promises.push(new Promise(async (resolve,reject)=>{\n          \n          // if node is undefined now, continue to the next one\n          if(!node){\n            // continue;\n            return resolve();\n          }\n          \n          \n          // returnNodes.push(node);\n          // return resolve();\n          \n          // Get all General PermissionFunctions \n          // - iterate through each \n          // - most will simply say \"i'm not concerned with this NodeType/Scenario\" \n          // - ordering by the \"type:order_level ChildNode\" \n          let returnedMoreThanPassThrough = false;\n          for(let funcNode of permissionFunctionNodes){\n            if(!node){\n              // skipping more permissionFunctions cuz already denied! \n              continue;\n            }\n            \n            // each permissionFunction can return 1 of 3 things: \n            // - true: if had no effect/match, passed-through \n            // - object: aka \"specifically allowed\" - passed permission function, potentially modified object on pass-through  \n            // - undefined: not allowed \n            \n            let codeNode = universe.lodash.find(funcNode.nodes, {type: 'code:0.0.1:local:32498h32f2'});\n            let simpleCompareNode = universe.lodash.find(funcNode.nodes, {type: 'simple_compare:0.0.1:local:298fy38y283'});\n            \n            let strFunc;\n            let permissionResult;\n            try {\n              \n              // permissionResult = await universe.runNodeCodeInVM({\n              //   codeNode, // includes type/schemaName and data.code\n              //   dataNode: node, // should be another Node that can be used by the action! \n              //   // timeout: 5000\n              //   workGroup,\n              //   workers: 10\n              // });\n              \n              \n              vmFuncCount++;\n              // permissionResult = await universe.runNodeCodeInVMSimple({\n              //   codeNode: simpleCompareNode, // includes type/schemaName and data.code\n              //   dataNode: {\n              //     type: 'props_for_simple_vm:0.0.1:local:378232h73h2',\n              //     data: {\n              //       inputNode: node, // should be another Node that can be used by the action! \n              //       requestCache \n              //     }\n              //   }\n              // });\n              \n              strFunc = simpleCompareNode.data.code;\n              let INPUT = {\n                type: 'props_for_simple_vm:0.0.1:local:378232h73h2',\n                data: {\n                  inputNode: node,\n                  requestCache\n                }\n              }\n              let miniverse = {\n                lodash: universe.lodash\n              }\n              // console.log('strFunc:',strFunc.length);\n              permissionResult = eval(strFunc); // can't use Function cuz loses local scope\n              permissionResult = await Promise.resolve(permissionResult)\n              \n            }catch(err){\n              // return resolve('FAILED code from incoming_web_request');\n              permissionResult = undefined;\n              console.error('Failed in code from permission_function',err, strFunc);\n            }\n            \n            // await universe.historyLog({typeofp: (typeof permissionResult), permissionResult}, 'permission_result', 'debug')\n        \n            switch(typeof permissionResult){\n              case 'boolean':\n                if(!permissionResult){\n                  node = undefined;\n                }\n                break;\n                \n              case 'object':\n                returnedMoreThanPassThrough = true;\n                node = permissionResult;\n                break;\n                \n              default:\n                // result was undefined,null,etc.\n                node = undefined;\n                break;\n            }\n            \n          }\n          \n          // ...finished permissionFunctions \n          \n          if(!node){\n            // process next node \n            // continue;\n            return resolve();\n          }\n          \n          // if all the results are \"true\" (aka only did pass-through) then DENY! \n          // - defaulting to \"don't show shit\" :) \n          if(!returnedMoreThanPassThrough){\n            // continue;\n            return resolve();\n          }\n          \n          \n          returnNodes.push(node);\n          return resolve();\n          \n          // permission functions should also be adding to the \"permissionQueue\" \n          // - make it easier to say \"if I passed X permission, then ignore this thing\" \n          // - kinda already there by default: could modify the request keyValue store and stack? \n          //   - but not able to do that from miniverse...race condition for \"next\" permissionFunction? \n          \n          // permission_function:0.0.1:local:2387872h3f2\n          \n          \n          // Get permissionFunctions for this NodeType \n          // - fetch first single Node that has type:permission_function_for_type (or use \"has common_name:permission_function\"??) \n          \n          // Get final \"global\" permissionFunction \n          // - per-user? \n          // - what other permission functions should run? \n          \n          \n        }));\n        \n        \n      });\n      \n      \n      // await universe.historyLog({INPUT}, 'searching-internal-datasource3 (got return nodes)', 'debug')\n      \n      Promise.all(promises)\n      .then(async ()=>{\n        \n        // console.log('vmFuncCountSetup:', vmFuncCount);\n      \n        // after we determine what a user is allowed to see...\n        // - manipulate === see !! (dont pretend that keeping things hidden here prevents what a user can output) \n        // - could easily say \"match Nodes that have X\" and even though we hide X, they know it exists cuz the ParentNode comes back \n        \n        // pass resulting Node to user's provided MatchFunction to see if this is a Node they want returned \n        // - their function also handles the amount of data they want to receive (any Children, etc.) \n        // - returning undefined means they DO NOT want it included \n        \n        let middleTime = (new Date()).getTime();\n        \n        let finalReturnNodes = [];\n        for(let node of returnNodes){\n          \n          let transformedResult;\n          let strFunc = INPUT.data.matchFunctionNode.data.code;\n          \n          try {\n            // vmFuncCount++;\n            // transformedResult = await universe.runNodeCodeInVMSimple({\n            //   codeNode: INPUT.data.matchFunctionNode, // includes type/schemaName and data.code\n            //   dataNode: {\n            //     type: 'props_for_simple_vm:0.0.1:local:378232h73h2',\n            //     data: {\n            //       inputNode: node, // should be another Node that can be used by the action! \n            //       // requestCache \n            //     }\n            //   }\n            //   // timeout: 5000\n            // });\n            \n            let INPUT = {\n              type: 'props_for_simple_vm:0.0.1:local:378232h73h2',\n              data: {\n                inputNode: node,\n                // requestCache\n              }\n            }\n            let miniverse = {\n              lodash: universe.lodash\n            }\n            // console.log('strFunc:',strFunc.length);\n            transformedResult = eval(strFunc); // can't use Function cuz loses local scope\n            transformedResult = await Promise.resolve(transformedResult)\n          }catch(err){\n            // return resolve('FAILED code from incoming_web_request');\n            transformedResult = undefined;\n            console.error('Failed user function:', err);\n          }\n          \n          if(transformedResult){\n            finalReturnNodes.push(transformedResult);\n          }\n          \n        }\n        \n        \n        let endTime = (new Date()).getTime();\n        \n//         universe.console.log(`\n// Internal Search Times: \n// total: ${(endTime - startTime)/1000}\n// searchMemorySetup: ${(memoryTime - startTime)/1000}\n// internalSetup: (${nodes.length}) ${(middleTime - memoryTime)/1000}\n// userFuncs: (${returnNodes.length}) ${(endTime - middleTime)/1000}\n// vmFuncCount: ${vmFuncCount}\n//         `);\n            \n        resolve({\n          type: 'list_of_nodes:0.0.1:local:3289f2',\n          data: finalReturnNodes\n        });\n        \n      });\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()",
    "key": "7090f3d5-3b0b-4c8f-9e44-c01ebf7da87f"
  },
  "active": true,
  "createdAt": 1521003431582,
  "updatedAt": 1522793298344
}