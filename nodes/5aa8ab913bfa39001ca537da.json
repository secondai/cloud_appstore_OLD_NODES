{
  "_id": "5aa8ab913bfa39001ca537da",
  "nodeId": "5aa8ab913bfa39001ca537d9",
  "type": "code:0.0.1:local:32498h32f2",
  "data": {
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      // Load the \"Identify with Remote Second\" capability\n      // order_level:0.0.1:local:382hf273\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      switch(inputAction){\n        \n        case 'createLocal': // should only happen once! \n          console.log('Create a new Local Private Identity');\n              \n          var key = new universe.rsa({b: 512});\n          key.generateKeyPair(512, 65537); // 2048\n          \n          const keypair = {\n            private: key.exportKey('pkcs8-private-pem'), \n            public: key.exportKey('pkcs8-public-pem'),\n          }\n          \n          let NodeToSave = {\n            type: 'identity_private:0.0.1:local:3298f2j398233',\n            data: keypair\n          }\n          \n          // save Node to memory\n          let savedNode = await universe.newNode(NodeToSave);\n          \n          // save the connectMethod as well \n          let connectionUrl = 'http://localhost:9999';\n          switch(universe.env.PUBLIC_HOST){\n             case 'localtunnel.me':\n             case 'ngrok.io':\n             case 'herokuapp.com':\n             default:\n              if(universe.env.HEROKU_APP_NAME){\n                connectionUrl = `https://${universe.env.HEROKU_APP_NAME}.herokuapp.com/ai`; \n              } else {\n                connectionUrl = `https://${universe.env.PUBLIC_SUBDOMAIN}.${universe.env.PUBLIC_HOST}/ai`;\n              }\n              break;\n          }\n          \n          console.log('CONNECTION_URL:', connectionUrl);\n          \n          let childNodeToSave = {\n            nodeId: savedNode._id,\n            type: 'private_identity_connect_method:0.0.1:local:9081j29h3',\n            data: {\n              method: 'http',\n              connection: connectionUrl\n            }\n          }\n          \n          let savedChildNode = await universe.newNode(childNodeToSave);\n          // delete savedChildNode.parent; // kill recursion\n          savedNode.nodes = [savedChildNode];\n          \n          return resolve(savedNode);\n          \n        case 'getPrivate':\n        \n          let privateNodes;\n          try{\n            privateNodes = await universe.searchMemory({\n              filter: {\n                sqlFilter: {\n                  nodeId: null,\n                  type: 'identity_private:0.0.1:local:3298f2j398233'\n                }\n              }\n            });\n            if(!privateNodes.length){\n              throw \"No private identity\";\n            }\n          }catch(err){\n            return reject({\n              type: 'err:.,sfj3',\n              err: 'shit, no identity'\n            });\n          }\n\n          let IdentityNode = privateNodes[0];\n          return resolve(IdentityNode);\n          \n        case 'getExternal':\n        \n          let externalNodes;\n          try{\n            externalNodes = await universe.searchMemory({\n              filter: {\n                sqlFilter: {\n                  nodeId: null,\n                  type: 'external_identity:0.0.1:local:8982f982j92',\n                  data: {\n                    publicKey: inputOpts.publicKey\n                  }\n                }\n              }\n            });\n            if(!externalNodes.length){\n              throw \"No external identity\";\n            }\n          }catch(err){\n            return reject({\n              type: 'err:.,sfj3',\n              err: 'shit, no external identity match'\n            });\n          }\n\n          let ExternalIdentityNode = externalNodes[0];\n          return resolve(ExternalIdentityNode);\n          \n          \n        case 'registerOnChain':\n          let remoteCreated = await universe.createAddressForIdentity(inputOpts.words, inputOpts.publicKey, inputOpts.connection)\n          return resolve(remoteCreated);\n          \n        case 'manageData':\n          let manageDataResult = await universe.manageData(inputOpts.network, inputOpts.username, inputOpts.field, inputOpts.nodeValue)\n          return resolve(manageDataResult);\n          \n          \n        case 'saveExternal':\n          // Duplicate publicKeys get updated! \n          \n          console.log('saveExternal inputOpts', inputOpts);\n          \n          let externalNodes3 = await universe.searchMemory({\n            filter: {\n              sqlFilter: {\n                nodeId: null,\n                type: 'external_identity:0.0.1:local:8982f982j92',\n                data: {\n                  publicKey: inputOpts.ExternalIdentityNode.data.publicKey\n                }\n              }\n            }\n          });\n          \n          let NodeToSave3 = {\n            type: 'external_identity:0.0.1:local:8982f982j92',\n            data: {\n              publicKey: inputOpts.ExternalIdentityNode.data.publicKey\n            }\n          }\n          \n          if(externalNodes3 && externalNodes3.length){\n            // exists!\n            NodeToSave3._id = externalNodes3[0]._id;\n          }\n          \n          // external_identity:0.0.1:local:8982f982j92\n          // external_identity_connect_method:0.0.1:local:382989239hsdfmn\n          \n          // save Node to memory\n          let savedNode3;\n          if(NodeToSave3._id){\n            savedNode3 = await universe.updateNode(NodeToSave3);\n          } else {\n            savedNode3 = await universe.newNode(NodeToSave3);\n          }\n          \n          // save/update the connectMethod as well \n          if(inputOpts.ExternalIdentityNode.nodes){\n            let childNodeToSave3 = {\n              nodeId: savedNode3._id,\n              type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn',\n              data: inputOpts.ExternalIdentityNode.nodes[0].data\n            }\n            \n            let savedChildNode3;\n            if(externalNodes3 && externalNodes3.length && externalNodes3[0].nodes){\n              childNodeToSave3._id = externalNodes3[0].nodes[0]._id;\n              savedChildNode3 = await universe.updateNode(childNodeToSave3);\n            } else {\n              savedChildNode3 = await universe.newNode(childNodeToSave3);\n            }\n          }\n          \n          console.log('Saved External, locally');\n          \n          let NewExternalNode = await universe.loadAndRunCapability('Identity',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'getExternal',\n              options: {\n                publicKey: inputOpts.ExternalIdentityNode.data.publicKey\n              }\n            }\n          });\n          \n          console.log('Got New/UpdatedExternalNode', NewExternalNode);\n          \n          return resolve(NewExternalNode);\n          \n          \n        \n        case 'getAddressForWords':\n          // inputOpts.words = String;\n          // transform to \"string[space]string[space]string[space]\" format \n          let remoteValue = universe.lodash.compact(inputOpts.words.split(' ')).join(' ');\n          // transform to wallet address \n          var hash = universe.bitcoin.crypto.sha256(remoteValue)\n          console.log('hash:', hash);\n          var d = universe.bigi.fromBuffer(hash)\n          console.log('d:', d);\n          var keyPair = new universe.bitcoin.ECPair(d)\n          var address = keyPair.getAddress()\n          console.log('Remote Second Wallet Address', address);\n          return resolve({\n            type:'wallet_address:..',\n            data: address\n          })\n          \n        default:\n          break;\n      }\n      \n      return reject();\n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()",
    "key": "e830f0fd-5313-48a7-8518-c431c5b4c7bb",
    "version": "2",
    "author": "-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCcuXovU+RZy85KMqLakYSH1mdV\nWdpEUtgcXUyGyU5hVeTO7BkV/kxeC2upcxOwNnrBOdsvHI3nrrILgt90/hCSHKzx\nhOFLREorGoKtSEHxI7/SnzzlWtV3gT/IP5GVHIyvuJBx3hCti0dH55DZG8iMGZ2y\ncGpV73Dez3hHmeBh6wIDAQAB\n-----END PUBLIC KEY-----"
  },
  "active": true,
  "createdAt": 1521003409902,
  "updatedAt": 1521846064216
}