{
  "_id": "5aa8ab833bfa39001ca537c4",
  "nodeId": "5aa8ab813bfa39001ca537c1",
  "type": "code:0.0.1:local:32498h32f2",
  "data": {
    "key": "2f6997c5-7c0f-4864-95e2-00b92047a427",
    "code": "(()=>{\n  \n  // This code handles an incoming \"run_action_sequence...\"\n  \n  // expcting a Node that specifies an array of actions to run! \n  // - this is useful when you want to include Authentication \n  //   - every command should include Auth+More \n\n  \n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      // return resolve({\n      //   multiple: 'todo: run multiple actions in sequence!'\n      // });\n      \n      // Should be piping information?? \n      // - just looping for now, expecting to store info in the cache, I guess?? \n      let actionResponses = [];\n      let continueActions = true;\n      for(let INPUT_data_idx in INPUT.data.actions){\n        if(!continueActions){\n          continue;\n        }\n        let INPUT_data = INPUT.data.actions[INPUT_data_idx];\n        \n        let x = 1; // this IS available in the filterNode function below!? \n        \n        let nodes = await universe.searchMemory({\n          filter: {\n            // sqlFilter: {\n            //   type: INPUT.type,\n            // },\n            // function for returning data from the Node, after filtering a bit \n            // - includes both the Node, and Nodes with nodeId (pointers) \n            filterNodes: tmpNodes=>{\n              // this runs isolated, outside of the above context? (not sure) \n              return new Promise((resolve, reject)=>{\n                tmpNodes = tmpNodes.filter(tmpNode=>{\n                  // see if has a ChildNode matching a type \n                  \n                  // // must match action type \n                  // if(tmpNode.type != INPUT.data.matchActionType){\n                  //   return false;\n                  // }\n                  // if(tmpNode.type != 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f'){\n                  //   return false;\n                  // }\n                  \n                  // if(INPUT.data.matchActionType != 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f'){\n                  //   return false;\n                  // }\n                  \n                  if(tmpNode.type != INPUT_data.matchActionType){\n                    return false;\n                  }\n                  // search_internal_datasource:0.0.1:local:2h3ufih8s9h2f\n                  \n                  // // must have code to run! \n                  // let foundChildCode = (tmpNodes.nodes || []).find(tmpChildNode=>{\n                  //   return tmpChildNode.type == 'code:0.0.1:local:32498h32f2';\n                  // });\n                  \n                  // if(!foundChildCode){\n                  //   return false;\n                  // }\n                  \n                  return true;\n                });\n                resolve(tmpNodes);\n              });\n            },\n          }\n        });\n        \n        // return resolve({\n        //   test: 'ok',\n        //   typeMatch: INPUT.data.matchActionType,\n        //   nodes,\n        //   INPUT,\n        //   SELF\n        // });\n        \n        if(nodes && nodes.length){\n          // found Node to run for action! \n          // - assuming only 1 piece of Code possible/available \n          \n          let codeNode = universe.lodash.find(nodes[0].nodes,{type:'code:0.0.1:local:32498h32f2'});\n          \n          // run in vm, and pass in the inputSchema Node! \n          // - of the action! (expecting/requiring it to be a Node w/ code....how to verify that? logic vs data?) \n          let actionResult;\n          try {\n            actionResult = await universe.runNodeCodeInVM({\n              codeNode, // includes type/schemaName and data \n              dataNode: INPUT_data.dataForAction, // should be another Node that can be used by the action! \n              timeout: 25 * 1000\n            });\n          }catch(err){\n            // return resolve('FAILED action');\n            actionResponses.push({\n              error: true,\n              msg: 'Failed action',\n              err: (err || '').toString()\n            });\n            continueActions = false;\n            continue;\n          }\n          \n          // validate actionResult!\n          // - todo\n          \n          // adding actionResult to results output\n          // return resolve(actionResult);\n          actionResponses.push(actionResult);\n          \n        } else {\n          // no Node found for handling action :( \n            \n          // return resolve({ \n          //   error: 'No Nodes for action2'\n          // }); // + result);\n          actionResponses.push({ \n            action3: INPUT_data,\n            error: 'No Nodes for action2'\n          });\n        }\n        \n      }\n      \n      // resolve all\n      resolve({\n        actionResponses\n      });\n      \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n  })\n\n  \n})()"
  },
  "active": true,
  "createdAt": 1521003395535,
  "updatedAt": null
}