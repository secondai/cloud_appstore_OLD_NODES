{
  "_id": "5aa8ab7f3bfa39001ca537bf",
  "nodeId": "5aa8ab7f3bfa39001ca537be",
  "type": "code:0.0.1:local:32498h32f2",
  "data": {
    "key": "b043bd65-9e3d-4bcb-bb89-0327b2e99687",
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // ONLY FOR: generic_cloud_second \n      \n      // handles an incoming Node from the Universe \n      // - handles the majority of request types:\n      //   - web request \n      //   - internal heartbeat \n      //   - internal \"wakeup\" \n      \n      // This accepts a Node that defines the type of data it is, and how we should start handling the request \n      // - the \"if I know nothing, learn things\" command is in here as well \n      \n      // console.log('INPUT:', JSON.stringify(INPUT,null,2));\n      \n      \n      switch(INPUT.type){\n          \n        case 'incoming_first:0.1.1:local:78882h37':\n          \n          console.log('INCOMING FIRST1!!');\n          \n          // INPUT is an ExternalIdentityNode\n          // return resolve({\n          //   learning: true,\n          //   INPUT\n          // });\n          \n          // Determine if environment if browser, cloud, app\n          // - determine if we ask for what to download? \n          \n          // This is called only once, after \"learnBasics\" populated default Nodes \n          // - basic capabilities are included/available  \n          \n          // Need to create a local Identity, and authenticate with the remote Second to Learn from \n          // - uses a constant value (token) from the remote Second! \n          let newIdentityNode = await universe.loadAndRunCapability('Identity',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'createLocal',\n              options: {}\n            }\n          });\n          \n          console.log('newIdentityNode', JSON.stringify(newIdentityNode,null,2));\n          \n          \n          // STOPPING HERE! \n          // - not \"learning\" anything from remote, just using whatever is currently available (JSON-start)\n          \n          console.log('Created Identity on _first, Second all ready!');\n          \n          // Register Identity on remote \n          let registeredExternal = await universe.loadAndRunCapability('Identity',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'registerOnChain',\n              options: {\n                words: universe.env.STARTUP_REACHABLE_WORDS,\n                publicKey: newIdentityNode.data.public,\n                connection: newIdentityNode.nodes[0].data.connection\n              }\n            }\n          });\n          \n          \n          return resolve({\n            type: 'something2...',\n            data: {\n              createdIdentity: true,\n              registeredExternal\n              // WORDS: universe.env.STARTUP_REACHABLE_WORDS,\n              // publicKey: newIdentityNode.data.public,\n              // connection: newIdentityNode.nodes[0].data.connection\n            }\n          });\n          \n          \n          \n          \n          // // Find remote Second \n          // // - hash of keywords -> wallet address -> encrypted via last keyword? \n          // // - want a publicKey and a URL returned \n          // //   - a whole IdentityNode should be returned? \n          // // - return: \n          // //   - external_identity:0.0.1:local:8982f982j92\n          // //   - external_identity_connect_method:0.0.1:local:382989239hsdfmn\n          \n          // let remoteValue;\n          // try {\n          //   remoteValue = 'test test'; //WINDOW.prompt('Remote Second','test test');\n          // }catch(err){\n          //   console.error('Not in Tab');\n          //   remoteValue = 'test test';\n          // }\n          \n          // // Need to create a local Identity, and authenticate with the remote Second to Learn from \n          // // - uses a constant value (token) from the remote Second! \n          // let addressNode = await universe.loadAndRunCapability('Identity',{},{\n          //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n          //   data: {\n          //     action: 'getAddressForWords',\n          //     options: {\n          //       words: remoteValue\n          //     }\n          //   }\n          // });\n          \n          // let address = addressNode.data;\n          \n          // // fetch that wallet address, get the first transaction \n          // // - first transaction contains IPFS link \n          // // - IPFS contains Nodes (without _ids!) \n          // let ExternalIdentityNode = await universe.getIdentityForAddress(address);\n          \n          // // console.log('Got ExternalIdentityNode',ExternalIdentityNode);\n          \n          // // return resolve({\n          // //   ExternalIdentityNode,\n          // //   error: true,\n          // //   remoteValue,\n          // //   address\n          // // })\n          \n          // // return resolve({\n          // //   aboutToIdentity: true\n          // // });\n          \n          // // Authenticate with External Second \n          // // - make authenticated requests to a Second (necessary for Learning?) \n          // //   - should have ALL requests authenticated \n          // // universe.setupExternalSecond();\n          // let authExternalIdentityNode = await universe.loadAndRunCapability('IdentifyInitiate',{},{\n          //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n          //   data: {\n          //     action: 'start',\n          //     options: {\n          //       externalIdentityPublicKey: ExternalIdentityNode.data.publicKey,\n          //       authToken: 'eeaac41bdb1b717d137a53779db97457:07e0fbe19e72c3ff7e329fc293bcf5b51d780c4c3c60f80403b2fea8f30d0daa5e4891dbdd6c57d9844622078a681853f31202d0632f0ee95031c9369a60708ddb6220e248e3c2ec6b3bb3c00eb2425aea922351d7128ef333ea5fe6a8ad139c1978759e29b057db1e655f2fe7c8962e'\n          //     }\n          //   }\n          // });\n          \n          // console.log('FINISHED INITIATE!', authExternalIdentityNode);\n          \n          // // console.log('ExternalIdentityNode', JSON.stringify(ExternalIdentityNode,null,2));\n          \n          // // Connect to passed-in data (ExternalIdentityNode) \n          // // - run a search_internal_datasource action sequence to acquire the code to run \n          // // - run the code on local Second  \n          // let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n          //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n          //   data: {\n          //     action: 'send',\n          //     options: {\n          //       ExternalIdentityNode,\n          //       RequestNode: {\n          //         type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n          //         data: {\n          //           actions: [\n                            \n          //             {\n          //               matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n          //               dataForAction: {\n          //                 type: 'string:...',\n          //                 data: 'eeaac41bdb1b717d137a53779db97457:07e0fbe19e72c3ff7e329fc293bcf5b51d780c4c3c60f80403b2fea8f30d0daa5e4891dbdd6c57d9844622078a681853f31202d0632f0ee95031c9369a60708ddb6220e248e3c2ec6b3bb3c00eb2425aea922351d7128ef333ea5fe6a8ad139c1978759e29b057db1e655f2fe7c8962e' // \"learn\" token is here! pre-downloaded!\n          //               }\n          //             },\n                      \n          //             {\n          //               matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n          //               dataForAction: {\n          //                 type: 'standard_query_request:0.0.1:local:65723f2khfds',\n          //                 data: {\n          //                   matchFunctionNode: {\n          //                     // query here!\n          //                     // action_pointer:0.0.1:local:238972ncr\n          //                     type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n          //                     data: {\n          //                       code: `(()=>{\n          //                         // Action \n          //                         // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                  \n          //                         let inputNode = INPUT.data.inputNode;\n                                  \n          //                         if(inputNode.type != 'learning_pointer:0.0.1:local:3289h3238h92'){\n          //                           return null;\n          //                         }\n                                  \n          //                         if(inputNode.data.learn != 'generic_cloud_second'){\n          //                           return null;\n          //                         }\n                                  \n          //                         if(inputNode.nodeId){\n          //                           // should be root-level!\n          //                           return null;\n          //                         }\n                                  \n          //                         // strip childnodes\n          //                         // delete inputNode.nodes; \n          //                         // delete inputNode.parent;\n          //                         delete inputNode.data;\n          \n          //                         return inputNode;\n                                  \n          //                       })()`\n          //                     }\n          //                   },\n          //                   // expected/allowed schemas for return \n          //                   // outputSchemas: [\n          //                   //   'query_result:0.0.1:local:32490usfj23o23f',\n          //                   //   'internal_error_output:0.0.1:local:32948x2u3cno2c'\n          //                   // ]\n          //                 }\n          //               }\n          //             }\n          //           ]\n                    \n          //         }\n          //       }\n          //     }\n          //   }\n          // });\n          \n          // // console.log('Got Response from TalkToSecond3'); //, JSON.stringify(response,null,2));\n          \n          // // Response should include code! \n          // let codeResultNode = universe.lodash.find(response.data.actionResponses[1].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n          \n          \n          // console.log('Got Code to Run for generic_cloud_second');\n          \n          // // return resolve({\n          // //   runningRemoteCode: true,\n          // //   codeResultNode_type: codeResultNode.type\n          // // });\n          \n          // // Run code in local VM \n          // // - INPUT.data is ExternalIdentityNode \n          // // - clears local memory, gets remote app, KEEPS local identity! \n          // let localResult = await universe.runNodeCodeInVM({\n          //   codeNode: codeResultNode,\n          //   dataNode: INPUT.data\n          // });\n          \n          // return resolve({\n          //   externalResponse: true,\n          //   response,\n          //   codeResultNode,\n          //   localResult\n          // })\n          \n          \n        case 'incoming_wakeup:0.0.1:local:8923yf89h9h':\n          // Wakeup \n          // - handles loading capabilities that will be used later \n          //   - loads all Capabilities (require things in?), adds them to GlobalCache \n          //   - on subsequent requests, universe.capabilities() should work. \n          break;\n          \n        case 'incoming_heartbeat:0.0.1:local:23849u492348c7n9':\n          // Heartbeat (ever 1 second or so is expected) \n          break;\n          \n        case 'incoming_web_request:0.0.1:local:29832398h4723':\n          // request via HTTP post method (expressjs server expected) \n          // - headers and body are included\n          //   - body is JSON (expected to be!) \n          \n          // console.log('incoming_web_request!!');\n          // return resolve({\n          //   ok: true\n          // });\n              \n          // if(INPUT.type == 'run_action:0.0.1:local:2398y294c23'){\n            // this is the main/expected input\n            let nodes = await universe.searchMemory({\n              filter: {\n                sqlFilter: {\n                  nodeId: null // root-level\n                  // type: INPUT.type,\n                },\n                // function for returning data from the Node, after filtering a bit \n                // - includes both the Node, and Nodes with nodeId (pointers) \n                filterNodes: tmpNodes=>{\n                  // this runs isolated, outside of the above context? (not sure) \n                  return new Promise((resolve, reject)=>{\n                    tmpNodes = tmpNodes.filter(tmpNode=>{\n                      // see if has a ChildNode matching a type \n                      let foundMatcherChild = universe.lodash.find(tmpNode.nodes || [],tmpChildNode=>{\n                        return tmpChildNode.type == 'incoming_query_type_matcher:0.0.1:local:3242rx23rd3';\n                      })\n                      // 'run_action:0.0.1:local:2398y294c23'\n                      if(!foundMatcherChild){\n                        return false;\n                      }\n                      \n                      // should have no Parent!\n                      // - todo: put into a specific \"directory\" or nodelist\n                      if(tmpNode.parent){\n                        return false;\n                      }\n                      \n                      return foundMatcherChild.data.typeMatch == INPUT.data.type;\n                    });\n                    resolve(tmpNodes);\n                  });\n                },\n              }\n            });\n            \n            // return resolve({\n            //   nodes: nodes.length\n            // });\n            \n            \n            if(nodes.length === 1){\n              // found Node to run for action! \n    \n              let codeNode = universe.lodash.find(nodes[0].nodes,{type:'code:0.0.1:local:32498h32f2'});\n              \n              // run in vm, and pass in the inputSchema Node! \n              // - of the action! (expecting/requiring it to be a Node w/ code....how to verify that? logic vs data?) \n              let actionResult;\n              try {\n                actionResult = await universe.runNodeCodeInVM({\n                  codeNode, // includes type/schemaName and data \n                  dataNode: INPUT.data, // should be another Node that can be used by the action! \n                  timeout: 15 * 1000\n                });\n              }catch(err){\n                return resolve('FAILED code from incoming_web_request');\n              }\n              \n              // validate actionResult!\n              // - todo\n              \n              return resolve(actionResult);\n              // { \n              //   txt: 'Response:', \n              //   nodeTypes: nodes.map(n=>n.type),\n              //   actionResult\n              // }); // + result);\n              \n            } else {\n              // no Node found for handling action :( \n                \n              return resolve({ \n                error: 'No Nodes for action (incoming_web_request)',\n                INPUT\n              }); // + result);\n            }\n            \n            \n          break;\n          \n        case 'incoming_web_request_blob:0.0.1:local:293h98h92f3':\n          // todo: handle incoming Blob data \n          break;\n          \n        case 'incoming_web_request_websocket:0.0.1:local:293h98h92f3':\n          // todo: handle incoming websocket request \n          // - could also be on browser? \n          break;\n          \n        case 'incoming_browser_request:0.0.1:local:829329329f832':\n          // incoming request (if in a browser) \n          break;\n          \n          \n        default:\n          return resolve({\n            type: 'err:..',\n            data: {\n              msg: 'Missing valid input type',\n              INPUT\n            }\n          });\n      }\n\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  },
  "active": true,
  "createdAt": 1521003391963,
  "updatedAt": null
}