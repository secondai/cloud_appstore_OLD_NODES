{
  "_id": "5aa8aba33bfa39001ca537f6",
  "nodeId": "5aa8aba23bfa39001ca537f4",
  "type": "code:0.0.1:local:32498h32f2",
  "data": {
    "key": "87889324-ce31-45f8-b80d-4f6d7a39f356",
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      \n      // encrypt_string:0.0.1:local:329fj2938\n      let nodeId;\n      let publicKey;\n      let internalUserId; // for InternalUser \n      let InternalUserNode;\n      let tokenNode;\n      let decrypted;\n      let encrypted;\n      try {\n        \n          \n        // // Created encrypted token for identification \n        // let tokenDataString = JSON.stringify({\n        //   type: 'identity_token_encrypted:0.0.1:local:8928h9h88832',\n        //   data: {\n        //     internalId: null,\n        //     publicKey: 'learn'\n        //   }\n        // });\n        // // encrypt_string:0.0.1:local:329fj2938\n        // encrypted = await universe.capabilities().encryptPrivate({\n        //   type: 'string',\n        //   data: tokenDataString\n        // });\n        \n        decrypted = await universe.capabilities().decryptPrivate({\n          type: 'string',\n          data: INPUT.data\n        });\n        \n        // get the local public key from decrypted package (JSON string) \n        if(decrypted.type != 'string:0.0.1:local:289hf329h93'){\n          return resolve({\n            type: 'boolean:0.0.1:local:98h8fh28h3232f',\n            data: false,\n            extra: {\n              msg: 'Failed decrypting INPUT.data',\n              inputData: INPUT.data ? INPUT.data : 'NO INPUT DATA PROVIDED',\n              INPUT,\n              decrypted,\n              // encrypted,\n            }\n          });\n        }\n        tokenNode = JSON.parse(decrypted.data);\n        \n        nodeId = tokenNode.data.internalId;\n        publicKey = tokenNode.data.publicKey;\n        internalUserId = tokenNode.data.internalUserId;\n        // todo: expiresAt (force re-auth)\n      }catch(err){\n        return resolve({\n          type: 'boolean:0.0.1:local:98h8fh28h3232f',\n          data: false,\n          extra: {\n            INPUT,\n            decrypted,\n            // encrypted,\n            verified: false,\n            err: true,\n            errStr: err.toString()\n          }\n        });\n      }\n      \n      // create some default ExternalIdentityNodes for certain private keys \n      // - \"learning\" for example\n      let ExternalIdentityNode;\n      \n      switch(publicKey){\n        case 'learn':\n          // allow anyone who was pre-allowed \n            \n          ExternalIdentityNode = {\n            type: 'external_identity:0.0.1:local:8982f982j92',\n            data: {\n              roles: ['learn'],\n              publicKey\n            }\n          }\n          \n          break;\n        \n        \n        default:\n          // actual publicKey passed in \n          \n          // Get local ExternalIdentity if it exists \n          // - should exist, unless we deleted it! \n          let nodes = await universe.searchMemory({\n            filter: {\n              sqlFilter: {\n                _id: nodeId,\n                type: 'external_identity:0.0.1:local:8982f982j92',\n                data: {\n                  publicKey: publicKey\n                }\n              },\n              // function for returning data from the Node, after filtering a bit \n              // - includes both the Node, and Nodes with nodeId (pointers) \n              filterNodes: tmpNodes=>{\n                return tmpNodes;\n              }\n            }\n          });\n          \n          if(!nodes || !nodes.length){\n            \n            return resolve({\n              type: 'boolean:0.0.1:local:98h8fh28h3232f',\n              data: {\n                missingNode: true,\n                INPUT,\n              }\n            });\n            \n          }\n          \n          ExternalIdentityNode = nodes[0];\n          \n          // see if the InternalUser should also be included\n          if(internalUserId){\n            let InternalUserNodes = await universe.searchMemory({\n              filter: {\n                sqlFilter: {\n                  _id: internalUserId,\n                  type: 'internal_user:0.0.1:local:98h32',\n                }\n              }\n            });\n            if(InternalUserNodes.length){\n              InternalUserNode = InternalUserNodes[0];\n            } else {\n              console.error('Missing as InternalUser');\n            }\n          }\n           \n          break;\n        \n      }\n      \n      \n      // set in request cache \n      await universe.setRequestCacheKeyValue('IdentityNode',ExternalIdentityNode);\n      await universe.setRequestCacheKeyValue('InternalUserNode',InternalUserNode);\n      \n      return resolve({\n        type: 'boolean:0.0.1:local:98h8fh28h3232f',\n        data: true,\n        ExternalIdentityNode,\n        decrypted,\n        internalUserId,\n        InternalUserNode\n      });\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  },
  "active": true,
  "createdAt": 1521003427388,
  "updatedAt": null
}