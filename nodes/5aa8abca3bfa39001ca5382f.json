{
  "_id": "5aa8abca3bfa39001ca5382f",
  "nodeId": "5aa8ab3b3bfa39001ca537bd",
  "type": "code:0.0.1:local:32498h32f2",
  "data": {
    "key": "059b41f6-ed97-4c8c-b35e-c2b1218c81a1",
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // This code is downloaded to a browser and run! \n      // - deletes all existing nodes\n      // - fetches all of the remote child nodes for a learning pointer\n      //   - using a \"run_action_sequence\" \n      \n      // Capabilities required: \n      // - TalkToSecond \n      // - NodeLobotomy (CRUD) \n      \n      \n      // Assuming the correct ExternalIdentityNode has been passed in as well! \n      // - could just have it in code, but might as well keep it external? \n      \n      // let IdentityNode = null;\n      // let identities = await universe.searchMemory({\n      //   filter: {\n      //     sqlFilter: {\n      //       type: 'remote_datasource:0.0.1:local:298f3h92hf9s8dhf23f'\n      //     },\n      //     // function for returning data from the Node, after filtering a bit \n      //     // - includes both the Node, and Nodes with nodeId (pointers) \n      //     filterNodes: tmpNodes=>{\n      //       // this runs isolated, outside of the above context? (not sure) \n      //       return new Promise((resolve, reject)=>{\n      //         resolve(tmpNodes);\n      //       });\n      //     },\n      //   }\n      // });\n      \n      let appToGet;\n      try {\n        appToGet = WINDOW.prompt('App to use?','browser_developer');\n      }catch(err){\n        console.error('Not in Tab');\n        appToGet = 'browser_developer';\n      }\n      \n      let codeSearchTemplate = `(()=>{\n        // Action \n        // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n        \n        // type is props_for_vm\n        // inputNode is used by code_miniverse\n        let inputNode = INPUT.data.inputNode;\n        \n        if(inputNode.type != 'parent_of_nodes_to_learn:0.0.1:local:2839fh29'){\n          return null;\n        }\n        \n        if(inputNode.data.learn != '{{APP}}'){\n          return null;\n        }\n        \n        // strip childnodes\n        // delete inputNode.nodes; \n        // delete inputNode.parent;\n        delete inputNode.data;\n  \n        return inputNode;\n        \n      })()`\n      // console.log('codeSearchTemplate1', codeSearchTemplate);\n      codeSearchTemplate = codeSearchTemplate.split(\"{{APP}}\").join(appToGet)\n      // console.log('codeSearchTemplate2', codeSearchTemplate);\n      \n      // Get the node(s) to install \n      // - single node, with children \n      let nodeResponse = await universe.loadAndRunCapability('TalkToSecond',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'send',\n          options: {\n            ExternalIdentityNode: INPUT,\n            RequestNode: {\n              type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n              data: {\n                actions: [\n                  {\n                    matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                    dataForAction: {\n                      type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                      data: {\n                        matchFunctionNode: {\n                          // query here!\n                          // action_pointer:0.0.1:local:238972ncr\n                          type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                          data: {\n                            code: codeSearchTemplate\n                          }\n                        },\n                        // expected/allowed schemas for return \n                        // outputSchemas: [\n                        //   'query_result:0.0.1:local:32490usfj23o23f',\n                        //   'internal_error_output:0.0.1:local:32948x2u3cno2c'\n                        // ]\n                      }\n                    }\n                  }\n                ]\n                \n              }\n            }\n          }\n        }\n      });\n      \n      \n      // Keep our local Identity \n      // - cuz we're about to clear all the memory! \n      let myPrivateIdentity;\n      let identities = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: 'identity_private:0.0.1:local:3298f2j398233'\n          }\n        }\n      });\n      myPrivateIdentity = identities[0];\n      \n      // Clear existing nodes \n      await universe.clearMemory({});\n      \n      \n      // Force-write all new nodes \n      // - keeps nodeId correct for all children \n      // - todo: handle _id changes in \"data\" fields! \n      const saveChildNodes = (nodeId, childNodes) => {\n        return new Promise(async (resolve, reject)=>{\n\n          for(let tmpNode of childNodes){\n            let newChildNode = {\n              nodeId,\n              type: tmpNode.type,\n              data: tmpNode.data,\n            }\n            let savedChildNode = await universe.newNode(newChildNode);\n\n            if(tmpNode.nodes && tmpNode.nodes.length){\n\n              await saveChildNodes(savedChildNode._id, tmpNode.nodes);\n\n            }\n          }\n          resolve();\n        });\n      }\n      \n      \n      // Re-add my myPrivateIdentity \n      let savedPrivateIdentityNode = await universe.newNode(myPrivateIdentity);\n      await saveChildNodes(savedPrivateIdentityNode._id, myPrivateIdentity.nodes);\n          \n      // add all \"learned\" nodes \n      let parentNodesToLearn = nodeResponse.data.actionResponses[0].data;\n      for(let parentNode of parentNodesToLearn){\n        \n        for(let node of parentNode.nodes){\n          \n          // iterate\n          // - save this one, then start saving down tree\n          let newNode = {\n            nodeId: null,\n            type: node.type,\n            data: node.data,\n          }\n  \n          let savedNode = await universe.newNode(newNode);\n          await saveChildNodes(savedNode._id, node.nodes);\n        }\n      }\n      \n      // // Relearn Capabilities that are now available\n      // await universe.reloadCapabilities();\n      \n  \n      // // Run rsa capability \n      // let rsaCapNode = await universe.loadCapability('rsa');\n      // let keyNode = await universe.runCapability(rsaCapNode, {\n      //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n      //   data: {\n      //     action: 'new',\n      //     options: {b: 512}\n      //   }\n      // });\n      // try {\n      //   let keyNode = await universe.loadAndRunCapability('rsa',{},{\n      //     type: 'standard_capability_action:0.0.1:local:298j291bs',\n      //     data: {\n      //       action: 'new',\n      //       options: {b: 512}\n      //     }\n      //   });\n        \n      //   keyNode.data.generateKeyPair(2048, 65537);\n      //   console.log('RSA Capability worked!', keyNode.data.exportKey('pkcs8-public-pem'));\n      // }catch(err){\n      //   console.error('FAILED RSA',err);\n      // }\n      \n      \n      // // Create a new Local Identity\n      // let newIdentityNode = await universe.loadAndRunCapability('Identity',{},{\n      //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n      //   data: {\n      //     action: 'createLocal',\n      //     options: {}\n      //   }\n      // });\n      \n      // console.log('newLocalIdentity:', newIdentityNode);\n      \n      // Identify with Remote \n      // - and setup to use that token going forward! \n      // let keyNode = await universe.loadAndRunCapability('rsa',{},{\n      //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n      //   data: {\n      //     action: 'new',\n      //     options: {b: 512}\n      //   }\n      // });\n      \n      \n      let allNodesAfterLearning = await universe.searchMemory({});\n      console.log('allNodesAfterLearning',allNodesAfterLearning);\n      \n      return resolve({\n        learned: true,\n        // nodesToLearn,\n        myPrivateIdentity\n      });\n      \n      \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()",
    "note": "learning pointer browser_developer"
  },
  "active": true,
  "createdAt": 1521003466587,
  "updatedAt": null
}