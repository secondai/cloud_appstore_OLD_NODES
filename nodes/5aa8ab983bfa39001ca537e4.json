{
  "_id": "5aa8ab983bfa39001ca537e4",
  "nodeId": "5aa8ab963bfa39001ca537e2",
  "type": "code:0.0.1:local:32498h32f2",
  "data": {
    "key": "85ad165c-ff0a-43ce-9973-557aaa933357",
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Receiving an INPUT.data.passphrase for logging in! \n      // - MUST already be identified (in requests hash) \n      // - upgrades the internal hash to include a user?\n      \n      // get whatever is currently stored \n      // internalUserPassphrase = passphrase\n\n      // Find the InternalUser with that passphrase \n      // - todo: bcrypt! \n      \n      // if found User, then create a new Token that will be used for Identity \n      \n      // INPUT = {\n      //   type: 'internal_user_passphrase:0.0.1:local:289fh239h38h2',\n      //   data: {\n      //     passphrase: String\n      //   }\n      // }\n      \n      let requestCache = await universe.getRequestCache();\n      \n      let IdentityNode;\n      try {\n        IdentityNode = requestCache.keyvalue.IdentityNode;\n      }catch(err){\n      }\n      \n      if(!IdentityNode){\n        return resolve({\n          type: 'error:...',\n          data: {\n            msg: 'Missing IdentityNode in request (should use a run_action_sequence and include auth!)'\n          }\n        });\n      }\n      \n      \n      \n      \n      // Find the InternalUser for that passphrase \n      let internalUserMatches = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            nodeId: null,\n            type: 'internal_user:0.0.1:local:98h32',\n            data: {\n              passphrase: INPUT.data.passphrase\n            }\n          }\n        }\n      });\n      \n      if(!internalUserMatches || !internalUserMatches.length){\n        return resolve({\n          type: 'error:',\n          data: {\n            error: true,\n            msg: 'Missing InternalUser with passphrase',\n            passphrase: INPUT.data.passphrase,\n            INPUT\n          }\n        });\n      }\n      \n      if(internalUserMatches.length > 1){\n        console.error('Matched multiple internalUsers!');\n        return resolve({\n          type: 'error:',\n          data: {\n            error: true,\n            msg: 'Multiple InternalUser with passphrase',\n            passphrase: INPUT.data.passphrase\n          }\n        });\n      }\n      \n      let InternalUserNode = internalUserMatches[0];\n      \n      \n      // Upgrade the user's token with the InternalUser Node \n      \n      \n      \n      // Return a new token to use for subsequent requests \n      let tokenDataString = JSON.stringify({\n        type: 'identity_token_encrypted:0.0.1:local:8928h9h88832',\n        data: {\n          internalId: IdentityNode._id, //ExternalIdentityNode._id,\n          publicKey: IdentityNode.data.publicKey,\n          internalUserId: InternalUserNode._id\n        }\n      });\n      \n      \n      // encrypt_string:0.0.1:local:329fj2938\n      let encrypted = await universe.capabilities().encryptPrivate({\n        type: 'string',\n        data: tokenDataString\n      });\n      \n      let token = encrypted.data;\n      \n      // resolve({\n      //   type: 'string:',\n      //   data: encrypted.data\n      // });\n        \n      \n      return resolve({\n        type: 'upgrade_token_response:0.0.1:local:289fh2389h23sfsvds',\n        data: {\n          verified: true,\n          token,\n          IdentityNode\n        }\n      });\n        \n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  },
  "active": true,
  "createdAt": 1521003416075,
  "updatedAt": null
}