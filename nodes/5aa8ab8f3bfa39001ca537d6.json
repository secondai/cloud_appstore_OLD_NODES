{
  "_id": "5aa8ab8f3bfa39001ca537d6",
  "nodeId": "5aa8ab8e3bfa39001ca537d5",
  "type": "code:0.0.1:local:32498h32f2",
  "data": {
    "key": "8900db23-3166-4efc-a099-e39cc790bc84",
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      // Load the \"Identify with Remote Second\" capability\n      // order_level:0.0.1:local:382hf273\n      \n      // let newIdentityNode = await universe.loadAndRunCapability('IdentityInitiate',{},{\n      //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n      //   data: {\n      //     action: 'start',\n      //     options: {\n      //       externalIdentityPublicKey: ExternalIdentityNode,\n      //       authToken: 'eeaac41bdb1b717d137a53779db97457:07e0fbe19e72c3ff7e329fc293bcf5b51d780c4c3c60f80403b2fea8f30d0daa5e4891dbdd6c57d9844622078a681853f31202d0632f0ee95031c9369a60708ddb6220e248e3c2ec6b3bb3c00eb2425aea922351d7128ef333ea5fe6a8ad139c1978759e29b057db1e655f2fe7c8962e'\n      //     }\n      //   }\n      // });\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      let { externalIdentityPublicKey, authToken } = inputOpts;\n      \n      switch(inputAction){\n        case 'start':\n          break;\n          \n        default:\n          return reject();\n      }\n      \n      \n      // Currently ExternalIdentity is unique by the publicKey (cant have multiple identities with the same publicKey) \n      // - can have multiple connect_method's though! (websocket, etc.) \n      \n      // // INPUT: \n      // {\n      //   type: 'key_public:0.0.1:local:3928fhj2389f',\n      //   data: 'string'\n      // }\n      \n      \n      // Initiates a challenge with an external Second \n      // - ExternalIdentity should ALREADY EXIST locally! \n      //   - look it up from nodes by INPUT.data.publicKey \n      // - lookup by data:publicKey, childNode:type:connect_method \n      // - checks for local ExternalIdentity first! \n      // - \n      \n      // return resolve({\n      //   INPUT\n      // });\n      \n      \n      // Get local ExternalIdentity if it exists \n      let nodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: 'external_identity:0.0.1:local:8982f982j92',\n            data: {\n              publicKey: externalIdentityPublicKey\n            }\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            return tmpNodes;\n          }\n        }\n      });\n      \n      if(!nodes.length){\n        return resolve({\n          type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n          data: {\n            str: 'Missing existing ExternalIdentity node',\n            publicKey: INPUT.data\n          }\n        })\n      }\n      \n      let ExternalIdentityNode = nodes[0];\n      // else {\n      //   ExternalIdentityNode = {\n      //     // no _id yet! (will create/update later!) \n      //     type: 'external_identity:0.0.1:local:8982f982j92',\n      //     data: {\n      //       publicKey:INPUT.data\n      //     }\n      //   }\n      // }\n      \n      // has connect_method (external_identity_connect_method:0.0.1:local:382989239hsdfmn)?\n      let connectNode = universe.lodash.find(ExternalIdentityNode.nodes, {type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn'});\n      if(!connectNode){\n        return resolve({\n          type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n          data: {\n            str: 'Missing existing ExternalIdentity connect_method child!'\n          }\n        })\n      }\n      \n      \n      \n      // Initiate Auth Steps \n      // - send my publicKey, new challengeText that we want validated \n      \n      // Need to create a local Identity, and authenticate with the remote Second to Learn from \n      // - uses a constant value (token) from the remote Second! \n      let MyPrivateIdentity = await universe.loadAndRunCapability('Identity',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'getPrivate',\n          options: {}\n        }\n      });\n      \n      console.log('MY privateIdentity NODE', MyPrivateIdentity);\n      \n      // let MyPrivateIdentity = await universe.capabilities().privateIdentity();\n      let myPublicKey = MyPrivateIdentity.data.public;\n      let newChallenge = universe.uuidv4();\n      \n      console.log('Created NewChallenge:', newChallenge);\n      \n      // make Node request to datasource\n      let InitiateIdentifyNode = {\n        type: 'challenge_initiate_info:0.0.1:local:323023424234324dwf',\n        data: {\n          publicKey: myPublicKey,\n          challenge: newChallenge\n        }\n      }\n      let WrappedInitiateIdentifyNode = {\n        type: 'run_action:0.0.1:local:2398y294c23',\n        data: {\n          matchActionType: 'identify_challenge_start:0.0.1:local:3892fh83h46',\n          dataForAction: InitiateIdentifyNode\n        }\n      }\n      \n      // ExternalIdentityNode\n      console.log('Making ExternalInitialResponseNodeFull request');\n      let ExternalInitialResponseNodeFull = await universe.loadAndRunCapability('Request',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'make',\n          options: {\n            ExternalIdentityNode: ExternalIdentityNode,\n            RequestNode: WrappedInitiateIdentifyNode\n          }\n        }\n      });\n      \n      // let ExternalInitialResponseNodeFull = await universe.capabilities().externalRequest({\n      //   type: 'external_request_info:0.0.1:local:329fj239832h93f23',\n      //   data: {\n      //     ExternalIdentityNode, // must include connect_method\n      //     RequestNode: WrappedInitiateIdentifyNode\n      //   }\n      // });\n      console.log('ExternalInitialResponseNodeFull',ExternalInitialResponseNodeFull);\n      // response includes the \"output_generic\" wrapper \n      let ExternalInitialResponseNode = ExternalInitialResponseNodeFull.data;\n      \n      // // successful response: challenge_start_response\n      // return resolve({\n      //   ok: 'test1',\n      //   response: ExternalInitialResponse\n      // });\n      \n      // Received:\n      // - answered challenge, signed using Private Key of External, verify using their PublicKey \n      // - new challenge for me to answer (to verify myself!), so I can get a JWT! \n      // - \n      \n      \n      // Verify challenge I sent \n      console.log('Verifying challenge I sent', ExternalInitialResponseNode, ExternalIdentityNode);\n      let verified = await universe.loadAndRunCapability('rsa',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'verify',\n          options: {\n            ChallengeVerifyNode:{\n              type: '...',\n              data: {\n                challenge: newChallenge,\n                solution: ExternalInitialResponseNode.data.solution,\n                publicKey: ExternalIdentityNode.data.publicKey\n              }\n            }\n          }\n        }\n      });\n      \n      console.log('Local Verified response:', verified);\n      \n      // let verified = await universe.capabilities().verify({\n      //   type: 'challenge_verify:0.0.1:local:93fj92hj832ff2',\n      //   data: {\n      //     challenge: newChallenge,\n      //     solution: ExternalInitialResponseNode.data.solution,\n      //     publicKey: ExternalIdentityNode.data.publicKey\n      //   }\n      // });\n      // boolean Node is returned\n      if(!verified.data){\n        return resolve({\n          err: 'Failed verifiation!',\n          challenge: newChallenge,\n          solution: ExternalInitialResponseNode.data.solution,\n          publicKey: ExternalIdentityNode.data.publicKey\n        });\n      }\n      \n      \n      // return resolve({\n      //   verified: verified\n      // });\n      \n      \n      // Verified external! \n      // - now need to identify myself, by answering the challenge I was sent \n      // - really this could be completed in reverse (but might as well just do it here!) \n      //   - better to do it in a handshake, otherwise the External might just say \"I was only holding your info for a moment and I got tired of holding it while I didn't know who you were\" \n      \n      console.log('Signing remote challenge', ExternalInitialResponseNode);\n      let SignedNode = await universe.loadAndRunCapability('rsa',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'sign',\n          options: {\n            stringToSign: ExternalInitialResponseNode.data.challenge\n          }\n        }\n      });\n      \n      console.log('Local SignedNode response:', SignedNode);\n      \n      \n      // let SignedNode = await universe.capabilities().sign({\n      //   type: 'string:0.0.1:local:289hf329h93',\n      //   data: ExternalInitialResponseNode.data.challenge\n      // });\n      let privateConnectMethod = universe.lodash.find(MyPrivateIdentity.nodes, { type: 'private_identity_connect_method:0.0.1:local:9081j29h3' });\n      \n      console.log('AFter Search');\n      \n      if(privateConnectMethod){\n        console.log('Has privateConnectMethod!!!!', privateConnectMethod);\n      } else {\n        console.log('NO privateConnectMethod???');\n      }\n      \n      // Make Node request to External, using my publicKey and the challenge/solution I was sent \n      // - getting an encrypted token back for later auth requests \n      let GetIdentityTokenNode = {\n        type: 'challenge_get_token:0.0.1:local:9238f9hf923',\n        data: {\n          publicKey: myPublicKey,\n          challengeReceived: ExternalInitialResponseNode.data.challenge,\n          solution: SignedNode.data, // base64 string \n          connectMethod: privateConnectMethod ? privateConnectMethod.data : undefined\n        }\n      }\n      let WrappedTokenNode = {\n        type: 'run_action:0.0.1:local:2398y294c23',\n        data: {\n          matchActionType: 'identify_challenge_response:0.0.1:local:3289h988h293fh8h',\n          dataForAction: GetIdentityTokenNode\n        }\n      }\n      \n      console.log('Making ExternalTokenResponseFull request with WrappedTokenNode', WrappedTokenNode);\n      let ExternalTokenResponseFull = await universe.loadAndRunCapability('Request',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'make',\n          options: {\n            ExternalIdentityNode: ExternalIdentityNode,\n            RequestNode: WrappedTokenNode\n          }\n        }\n      });\n      \n      console.log('Local ExternalTokenResponseFull response:', ExternalTokenResponseFull);\n      \n      \n      // let ExternalTokenResponseFull = await universe.capabilities().externalRequest({\n      //   type: 'external_request_info:0.0.1:local:329fj239832h93f23',\n      //   data: {\n      //     ExternalIdentityNode, // must include connect_method\n      //     RequestNode: WrappedTokenNode\n      //   }\n      // });\n      \n      // return resolve({\n      //   x: 1,\n      //   ExternalTokenResponseFull\n      // });\n      console.log('AT IDENTIFY STAGE 2', ExternalIdentityNode);\n      \n      // response includes the \"output_generic\" wrapper \n      let ExternalTokenResponseNode = ExternalTokenResponseFull.data;\n      \n      // save updated ExternalIdentityNode\n      ExternalIdentityNode.data.token = ExternalTokenResponseNode.data.token; // assuming Node response w/ encrypted token as data\n      \n      console.log('Updating ExternalIdentityNode', ExternalIdentityNode);\n      let updatedExternalIdentityNode = await universe.updateNode(ExternalIdentityNode);\n      // todo: save\n      \n      console.log('Updated!');\n      \n      // check for publicKey info (ok to allow this person?) \n      // - after I send them something to sign and actually get their identity...\n      \n      resolve({\n        type: 'challenge_finish:0.0.1:local:2983jf982',\n        data: {\n          SUCCESS: {\n            ExternalInitialResponseNode,\n            ExternalTokenResponseNode,\n            SignedNode_data: SignedNode.data,\n            updatedExternalIdentityNode\n          }\n        }\n      });\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  },
  "active": true,
  "createdAt": 1521003407198,
  "updatedAt": null
}